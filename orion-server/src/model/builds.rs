//! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.15

use chrono::Utc;
use sea_orm::entity::prelude::*;
use sea_orm::{ActiveValue::Set, ConnectionTrait};
use serde::{Deserialize, Serialize};
use serde_json::Value;

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Serialize, Deserialize)]
#[sea_orm(table_name = "builds")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    pub id: Uuid,
    pub task_id: Uuid,
    pub target_id: Uuid,
    pub exit_code: Option<i32>,
    pub start_at: DateTimeWithTimeZone,
    pub end_at: Option<DateTimeWithTimeZone>,
    pub repo: String,
    #[sea_orm(column_type = "JsonBinary", nullable)]
    pub args: Option<Value>,
    pub output_file: String,
    pub created_at: DateTimeWithTimeZone,
    pub retry_count: i32,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(
        belongs_to = "super::tasks::Entity",
        from = "Column::TaskId",
        to = "super::tasks::Column::Id",
        on_update = "NoAction",
        on_delete = "Cascade"
    )]
    Tasks,
    #[sea_orm(
        belongs_to = "super::targets::Entity",
        from = "Column::TargetId",
        to = "super::targets::Column::Id",
        on_update = "NoAction",
        on_delete = "Cascade"
    )]
    Targets,
}

impl Related<super::tasks::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Tasks.def()
    }
}

impl Related<super::targets::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Targets.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}

impl Model {
    /// Create a new build ActiveModel for database insertion
    pub fn create_build(
        build_id: Uuid,
        task_id: Uuid,
        target_id: Uuid,
        repo: String,
        args: Option<Value>,
    ) -> ActiveModel {
        let now = Utc::now().into();
        let repo_leaf = repo
            .trim_end_matches('/')
            .rsplit('/')
            .next()
            .unwrap_or(&repo)
            .to_string();
        ActiveModel {
            id: Set(build_id),
            task_id: Set(task_id),
            target_id: Set(target_id),
            exit_code: Set(None),
            start_at: Set(now),
            end_at: Set(None),
            repo: Set(repo),
            args: Set(args),
            output_file: Set(format!("{}/{}/{}.log", task_id, repo_leaf, build_id)),
            created_at: Set(now),
            retry_count: Set(0),
        }
    }

    /// Insert a single build directly into the database
    pub async fn insert_build(
        build_id: Uuid,
        task_id: Uuid,
        target_id: Uuid,
        repo: String,
        db: &impl ConnectionTrait,
    ) -> Result<Model, DbErr> {
        let build_model = Self::create_build(build_id, task_id, target_id, repo, None);
        build_model.insert(db).await
    }
}
