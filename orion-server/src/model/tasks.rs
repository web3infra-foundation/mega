//! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.15

use sea_orm::entity::prelude::*;
use sea_orm::{ActiveValue::Set, ConnectionTrait, DbErr};
use serde::{Deserialize, Serialize};
use uuid::Uuid;

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Serialize, Deserialize)]
#[sea_orm(table_name = "tasks")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    pub id: Uuid,
    pub cl_id: i64,
    pub task_name: Option<String>,
    #[sea_orm(column_type = "JsonBinary", nullable)]
    pub template: Option<Json>,
    pub created_at: DateTimeWithTimeZone,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_many = "super::builds::Entity")]
    Builds,
    #[sea_orm(has_many = "super::targets::Entity")]
    Targets,
}

impl Related<super::builds::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Builds.def()
    }
}

impl Related<super::targets::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Targets.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}

impl Model {
    /// Retrieves build IDs associated with a task ID
    pub async fn get_builds_by_task_id(
        task_id: Uuid,
        db: &DatabaseConnection,
    ) -> Option<Vec<Uuid>> {
        // Query the builds table for all builds with the given task_id
        match super::builds::Entity::find()
            .filter(super::builds::Column::TaskId.eq(task_id))
            .all(db)
            .await
        {
            Ok(builds) => {
                // Extract the IDs from the builds
                let build_ids: Vec<Uuid> = builds.into_iter().map(|build| build.id).collect();
                Some(build_ids)
            }
            Err(e) => {
                tracing::error!("Failed to fetch builds for task_id {}: {}", task_id, e);
                None
            }
        }
    }

    /// Create a new task ActiveModel for database insertion
    pub fn create_task(
        task_id: Uuid,
        cl_id: i64,
        task_name: Option<String>,
        template: Option<Json>,
        created_at: DateTimeWithTimeZone,
    ) -> ActiveModel {
        ActiveModel {
            id: Set(task_id),
            cl_id: Set(cl_id),
            task_name: Set(task_name),
            template: Set(template),
            created_at: Set(created_at),
        }
    }

    /// Insert a task directly into the database
    pub async fn insert_task(
        task_id: Uuid,
        cl_id: i64,
        task_name: Option<String>,
        template: Option<Json>,
        created_at: DateTimeWithTimeZone,
        db: &impl ConnectionTrait,
    ) -> Result<Model, DbErr> {
        let task_model = Self::create_task(task_id, cl_id, task_name, template, created_at);
        task_model.insert(db).await
    }
}
