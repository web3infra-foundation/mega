import React, { useEffect, useRef, useState } from 'react'
import * as d3 from 'd3'

export interface CveAnalyzeRes {
  crate_version: string
  dept_crate_version: string[]
}

interface CveGraphProps {
  rootId: string // CVE-ID 作为根
  data: CveAnalyzeRes[] // 三层结构：root -> crate_version -> dep_crate_version
}

interface CveNode extends d3.SimulationNodeDatum {
  id: string
  level: 1 | 2 | 3 // 1: root(CVE), 2: crate, 3: dep
  color: string
}

interface CveLink extends d3.SimulationLinkDatum<CveNode> {
  source: CveNode
  target: CveNode
}

const CveGraph: React.FC<CveGraphProps> = ({ rootId, data }) => {
  const [graphReady, setGraphReady] = useState<boolean>(false)
  const containerRef = useRef<HTMLDivElement | null>(null)
  const [containerSize, setContainerSize] = useState<{ width: number; height: number } | null>(null)
  const didAutoFitRef = useRef<boolean>(false)

  useEffect(() => {
    setGraphReady(true)
  }, [data, rootId])

  // 监听容器尺寸变化，触发重绘
  useEffect(() => {
    if (!containerRef.current) return
    const el = containerRef.current

    const updateSize = () => {
      setContainerSize({ width: el.clientWidth, height: el.clientHeight })
    }

    updateSize()

    const ro = new (window as any).ResizeObserver(updateSize)

    ro.observe(el)
    return () => ro.disconnect()
  }, [])

  useEffect(() => {
    if (!graphReady || !containerRef.current) return

    const containerWidth = containerRef.current.clientWidth
    const containerHeight = containerRef.current.clientHeight

    // 清理旧图
    d3.select(containerRef.current).select('svg').remove()

    const width = containerWidth
    const height = containerHeight

    const svg = d3
      .select(containerRef.current)
      .append('svg')
      .attr('width', '100%')
      .attr('height', '100%')
      .attr('viewBox', `0 0 ${width} ${height}`)
      .attr('preserveAspectRatio', 'xMidYMid slice')

    svg
      .append('defs')
      .append('marker')
      .attr('id', 'cve-arrowhead')
      .attr('viewBox', '0 -5 10 10')
      .attr('refX', 7)
      .attr('refY', 0)
      .attr('orient', 'auto')
      .attr('markerWidth', 4)
      .attr('markerHeight', 4)
      .append('path')
      .attr('d', 'M 0,-5 L 10,0 L 0,5')
      .attr('fill', '#333')
      .style('stroke', 'none')

    const rootColor = 'rgb(229,72,77)' // 红色：CVE 根
    const crateColor = 'rgb(62,99,221)' // 蓝色：crate_version
    const depColor = 'rgb(50,224,196)' // 青色：dep_crate_version

    const nodesMap = new Map<string, CveNode>()
    const links: CveLink[] = []

    // 根节点
    const rootNode: CveNode = { id: rootId, level: 1, color: rootColor }

    nodesMap.set(rootNode.id, rootNode)

    // 第二层 & 第三层
    data.forEach((item) => {
      const crateId = item.crate_version

      if (!nodesMap.has(crateId)) {
        nodesMap.set(crateId, { id: crateId, level: 2, color: crateColor })
      }
      links.push({ source: nodesMap.get(rootNode.id)!, target: nodesMap.get(crateId)! })

      item.dept_crate_version.forEach((dep) => {
        const depId = `${crateId} -> ${dep}` // 保证唯一

        if (!nodesMap.has(depId)) {
          nodesMap.set(depId, { id: dep, level: 3, color: depColor })
        }
        links.push({ source: nodesMap.get(crateId)!, target: nodesMap.get(depId)! })
      })
    })

    const nodes = Array.from(nodesMap.values())

    const g = svg.append('g')

    const simulation = d3
      .forceSimulation<CveNode>(nodes)
      .force(
        'link',
        d3
          .forceLink<CveNode, CveLink>(links)
          .id((d) => d.id)
          .distance(140)
      )
      .force('charge', d3.forceManyBody().strength(-800))
      .force('center', d3.forceCenter(width / 2, height / 2))
      .force('collide', d3.forceCollide().radius(18))

    const link = g
      .append('g')
      .selectAll('line')
      .data(links)
      .enter()
      .append('line')
      .attr('stroke-width', 1)
      .attr('stroke', '#333')
      .attr('marker-end', 'url(#cve-arrowhead)')

    const node = g
      .append('g')
      .selectAll('circle')
      .data(nodes)
      .enter()
      .append('circle')
      .attr('r', (d) => (d.level === 1 ? 9 : 7))
      .attr('fill', (d) => d.color)
      .attr('stroke', '#333')
      .attr('stroke-width', 1)
      .call(d3.drag<SVGCircleElement, CveNode>().on('start', dragstarted).on('drag', dragged).on('end', dragended))

    node.append('title').text((d) => d.id)

    const labels = g
      .append('g')
      .selectAll('text')
      .data(nodes)
      .enter()
      .append('text')
      .attr('dy', '.35em')
      .text((d) => d.id)
      .style('font-family', '"HarmonyOS Sans SC"')
      .style('font-size', '12px')
      .style('font-weight', '400')
      .style('fill', '#000')

    simulation.nodes(nodes).on('tick', ticked)
    ;(simulation.force('link') as d3.ForceLink<CveNode, CveLink>).links(links)

    function ticked() {
      link
        .attr('x1', (d) => (d.source as CveNode).x!)
        .attr('y1', (d) => (d.source as CveNode).y!)
        .attr('x2', (d) => (d.target as CveNode).x!)
        .attr('y2', (d) => (d.target as CveNode).y!)

      node.attr('cx', (d) => d.x!).attr('cy', (d) => d.y!)

      labels.attr('x', (d) => (d.x ?? 0) + 12).attr('y', (d) => d.y ?? 0)
    }

    function dragstarted(event: d3.D3DragEvent<SVGCircleElement, CveNode, CveNode>, d: CveNode) {
      if (!event.active) simulation.alphaTarget(0.3).restart()
      d.fx = d.x
      d.fy = d.y
    }
    function dragged(event: d3.D3DragEvent<SVGCircleElement, CveNode, CveNode>, d: CveNode) {
      d.fx = event.x
      d.fy = event.y
    }
    function dragended(event: d3.D3DragEvent<SVGCircleElement, CveNode, CveNode>, d: CveNode) {
      if (!event.active) simulation.alphaTarget(0)
      d.fx = null
      d.fy = null
    }

    // 缩放/拖拽
    const zoom = d3
      .zoom<SVGSVGElement, unknown>()
      .scaleExtent([0.1, 20])
      .on('zoom', (event) => {
        g.attr('transform', event.transform)
        // 一旦发生用户缩放/平移，之后不再自动居中
        didAutoFitRef.current = true
      })

    svg.call(zoom)

    // 在模拟结束后，根据节点边界自动缩放并居中到容器（仅首次）
    didAutoFitRef.current = false // 初次渲染允许自动居中
    simulation.on('end', () => {
      if (didAutoFitRef.current) return
      const xs = nodes.map((n) => n.x ?? 0)
      const ys = nodes.map((n) => n.y ?? 0)
      const minX = Math.min(...xs)
      const maxX = Math.max(...xs)
      const minY = Math.min(...ys)
      const maxY = Math.max(...ys)
      const graphWidth = Math.max(1, maxX - minX)
      const graphHeight = Math.max(1, maxY - minY)
      const padding = 60 // 视图内边距
      const scale = Math.min((width - padding) / graphWidth, (height - padding) / graphHeight)
      const tx = (width - scale * (minX + maxX)) / 2

      const ty = (height - scale * (minY + maxY)) / 2

      svg.call(zoom.transform, d3.zoomIdentity.translate(tx, ty).scale(scale))
      didAutoFitRef.current = true
    })

    return () => {
      svg.remove()
    }
  }, [graphReady, containerSize, data, rootId])

  return (
    <div
      ref={containerRef}
      style={{
        width: '100%',
        height: '640px',
        overflow: 'hidden'
      }}
    />
  )
}

export default CveGraph
