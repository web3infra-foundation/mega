//! `SeaORM` Entity, @generated by sea-orm-codegen 1.1.19

use chrono::Utc;
use sea_orm::{ActiveValue::Set, entity::prelude::*, sea_query::OnConflict};
use serde::{Deserialize, Serialize};

use super::sea_orm_active_enums::OrionTargetStatusEnum;

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Serialize, Deserialize)]
#[sea_orm(table_name = "target_build_status")]
pub struct Model {
    #[sea_orm(primary_key, auto_increment = false)]
    pub id: Uuid,
    pub task_id: Uuid,
    #[sea_orm(column_type = "Text")]
    pub target_package: String,
    #[sea_orm(column_type = "Text")]
    pub target_name: String,
    #[sea_orm(column_type = "Text")]
    pub target_configuration: String,
    #[sea_orm(column_type = "Text")]
    pub category: String,
    #[sea_orm(column_type = "Text")]
    pub identifier: String,
    #[sea_orm(column_type = "Text")]
    pub action: String,
    pub status: OrionTargetStatusEnum,
    pub created_at: DateTimeWithTimeZone,
    pub updated_at: DateTimeWithTimeZone,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(
        belongs_to = "super::orion_tasks::Entity",
        from = "Column::TaskId",
        to = "super::orion_tasks::Column::Id",
        on_update = "Cascade",
        on_delete = "Cascade"
    )]
    OrionTasks,
}

impl Related<super::orion_tasks::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::OrionTasks.def()
    }
}

impl ActiveModelBehavior for ActiveModel {}

impl Model {
    /// Create a new ActiveModel for insertion/upsert
    #[allow(clippy::too_many_arguments)]
    pub fn new_active_model(
        id: Uuid,
        task_id: Uuid,
        target_package: String,
        target_name: String,
        target_configuration: String,
        category: String,
        identifier: String,
        action: String,
        status: OrionTargetStatusEnum,
    ) -> ActiveModel {
        let now = Utc::now().into();

        ActiveModel {
            id: Set(id),
            task_id: Set(task_id),
            target_package: Set(target_package),
            target_name: Set(target_name),
            target_configuration: Set(target_configuration),
            category: Set(category),
            identifier: Set(identifier),
            action: Set(action),
            status: Set(status),
            created_at: Set(now),
            updated_at: Set(now),
        }
    }

    /// Batch upsert into the database
    /// On conflict (task_id, action) update status and updated_at
    pub async fn upsert_batch(
        conn: &DatabaseConnection,
        models: Vec<ActiveModel>,
    ) -> Result<(), sea_orm::DbErr> {
        if models.is_empty() {
            return Ok(());
        }

        Entity::insert_many(models)
            .on_conflict(
                OnConflict::columns([Column::TaskId, Column::Action])
                    .update_columns([Column::Status, Column::UpdatedAt])
                    .to_owned(),
            )
            .exec(conn)
            .await?;

        Ok(())
    }

    /// Delete all targets by task_id
    pub async fn delete_by_task_id(
        conn: &DatabaseConnection,
        task_id: Uuid,
    ) -> Result<(), sea_orm::DbErr> {
        Entity::delete_many()
            .filter(Column::TaskId.eq(task_id))
            .exec(conn)
            .await?;
        Ok(())
    }

    /// Fetch all targets by task_id
    pub async fn fetch_by_task_id(
        conn: &DatabaseConnection,
        task_id: Uuid,
    ) -> Result<Vec<Model>, sea_orm::DbErr> {
        Entity::find()
            .filter(Column::TaskId.eq(task_id))
            .all(conn)
            .await
    }
}

impl Entity {
    /// Insert or update a single target status
    #[allow(clippy::too_many_arguments)]
    pub async fn upsert_one(
        conn: &DatabaseConnection,
        id: Uuid,
        task_id: Uuid,
        target_package: String,
        target_name: String,
        target_configuration: String,
        category: String,
        identifier: String,
        action: String,
        status: OrionTargetStatusEnum,
    ) -> Result<(), sea_orm::DbErr> {
        let model = Model::new_active_model(
            id,
            task_id,
            target_package,
            target_name,
            target_configuration,
            category,
            identifier,
            action,
            status,
        );

        Model::upsert_batch(conn, vec![model]).await
    }

    /// Batch upsert multiple target statuses
    pub async fn upsert_batch(
        conn: &DatabaseConnection,
        models: Vec<ActiveModel>,
    ) -> Result<(), sea_orm::DbErr> {
        Model::upsert_batch(conn, models).await
    }

    /// Fetch all targets by task_id
    pub async fn fetch_by_task_id(
        conn: &DatabaseConnection,
        task_id: Uuid,
    ) -> Result<Vec<Model>, sea_orm::DbErr> {
        Model::fetch_by_task_id(conn, task_id).await
    }

    /// Delete all targets by task_id
    pub async fn delete_by_task_id(
        conn: &DatabaseConnection,
        task_id: Uuid,
    ) -> Result<(), sea_orm::DbErr> {
        Model::delete_by_task_id(conn, task_id).await
    }

    /// Update the status of a specific target (by task_id + action)
    pub async fn update_status(
        conn: &DatabaseConnection,
        task_id: Uuid,
        action: &str,
        status: OrionTargetStatusEnum,
    ) -> Result<(), sea_orm::DbErr> {
        let now = chrono::Utc::now().into();

        Entity::update_many()
            .set(ActiveModel {
                status: Set(status),
                updated_at: Set(now),
                ..Default::default()
            })
            .filter(Column::TaskId.eq(task_id))
            .filter(Column::Action.eq(action))
            .exec(conn)
            .await?;

        Ok(())
    }
}
