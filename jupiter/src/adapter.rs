use crate::callisto::git_commit;
use crate::callisto::git_tag;
use crate::callisto::git_tree;
use crate::callisto::mega_commit;
use crate::callisto::mega_tree;
use crate::callisto::raw_blob;
use mercury::hash::SHA1;
use mercury::internal::object::blob::Blob;
use mercury::internal::object::commit::Commit;
use mercury::internal::object::signature::Signature;
use mercury::internal::object::tag::Tag;
use mercury::internal::object::tree::Tree;
use mercury::internal::object::types::ObjectType;
use std::str::FromStr;

/// Converts a callisto::raw_blob::Model to mercury::internal::object::blob::Blob
///
/// This function takes a database blob model and converts it to a Git blob object.
/// The SHA1 hash will be calculated from the blob content.
pub fn raw_blob_to_blob(model: raw_blob::Model) -> Blob {
    let data = model.data.unwrap_or_default();
    Blob::from_content_bytes(data)
}

/// Converts a mercury::internal::object::blob::Blob to callisto::raw_blob::Model
///
/// This function takes a Git blob object and converts it to a database blob model.
/// The ID is set to 0 and will be generated by the database upon insertion.
pub fn blob_to_raw_blob(blob: Blob) -> raw_blob::Model {
    use crate::callisto::sea_orm_active_enums::StorageTypeEnum;

    raw_blob::Model {
        id: 0,
        sha1: format!("{}", blob.id),
        content: None,
        file_type: None,
        storage_type: StorageTypeEnum::Database,
        data: Some(blob.data.clone()),
        local_path: None,
        remote_url: None,
        created_at: chrono::Utc::now().naive_utc(),
    }
}

/// Converts a callisto::git_tree::Model to mercury::internal::object::tree::Tree
///
/// This function takes a database tree model and converts it to a Git tree object.
/// It deserializes the tree items from the binary data stored in the model.
pub fn git_tree_to_tree(model: git_tree::Model) -> Tree {
    let (tree_items, _) =
        bincode::serde::decode_from_slice(&model.sub_trees, bincode::config::standard())
            .unwrap_or_else(|_| (Vec::new(), 0));

    Tree::from_tree_items(tree_items).expect("Failed to create Tree")
}

/// Converts a mercury::internal::object::tree::Tree to callisto::git_tree::Model
///
/// This function takes a Git tree object and converts it to a database tree model.
/// It serializes the tree items to binary data for storage.
/// The ID is set to 0 and will be generated by the database upon insertion.
pub fn tree_to_git_tree(tree: Tree, repo_id: i64) -> git_tree::Model {
    let sub_trees = bincode::serde::encode_to_vec(&tree.tree_items, bincode::config::standard())
        .expect("Failed to serialize tree items");

    let size = sub_trees.len() as i32;

    git_tree::Model {
        id: 0,
        repo_id,
        tree_id: format!("{}", tree.id),
        sub_trees,
        size,
        created_at: chrono::Utc::now().naive_utc(),
    }
}

/// Converts a callisto::mega_tree::Model to mercury::internal::object::tree::Tree
///
/// This function takes a database mega tree model and converts it to a Git tree object.
/// It deserializes the tree items from the binary data stored in the model.
pub fn mega_tree_to_tree(model: mega_tree::Model) -> Tree {
    let (tree_items, _) =
        bincode::serde::decode_from_slice(&model.sub_trees, bincode::config::standard())
            .unwrap_or_else(|_| (Vec::new(), 0));

    Tree::from_tree_items(tree_items).expect("Failed to create Tree")
}

/// Converts a mercury::internal::object::tree::Tree to callisto::mega_tree::Model
///
/// This function takes a Git tree object and converts it to a database mega tree model.
/// It serializes the tree items to binary data for storage and associates the tree with a commit ID.
/// The ID is set to 0 and will be generated by the database upon insertion.
pub fn tree_to_mega_tree(tree: Tree, commit_id: &str) -> mega_tree::Model {
    let sub_trees = bincode::serde::encode_to_vec(&tree.tree_items, bincode::config::standard())
        .expect("Failed to serialize tree items");

    let size = sub_trees.len() as i32;

    mega_tree::Model {
        id: 0,
        tree_id: format!("{}", tree.id),
        sub_trees,
        size,
        commit_id: commit_id.to_string(),
        created_at: chrono::Utc::now().naive_utc(),
    }
}

/// Converts a callisto::git_commit::Model to mercury::internal::object::commit::Commit
///
/// This function takes a database git commit model and converts it to a Git commit object.
/// It parses the parent commit IDs from JSON, extracts author and committer information,
/// and constructs a new Commit object with the appropriate data.
pub fn git_commit_to_commit(model: git_commit::Model) -> Commit {
    let parent_commit_ids: Vec<SHA1> =
        serde_json::from_str::<Vec<String>>(model.parents_id.to_string().as_str())
            .unwrap_or_default()
            .iter()
            .map(|id| SHA1::from_str(id).unwrap())
            .collect();

    let author = model
        .author
        .map(|a| Signature::from_data(a.into_bytes()).unwrap())
        .unwrap_or_else(|| {
            Signature::from_data(
                format!(
                    "author unknown <unknown@example.com> {} +0000",
                    chrono::Utc::now().timestamp()
                )
                .into_bytes(),
            )
            .unwrap()
        });

    let committer = model
        .committer
        .map(|c| Signature::from_data(c.into_bytes()).unwrap())
        .unwrap_or_else(|| {
            Signature::from_data(
                format!(
                    "committer unknown <unknown@example.com> {} +0000",
                    chrono::Utc::now().timestamp()
                )
                .into_bytes(),
            )
            .unwrap()
        });

    let message = model.content.unwrap_or_default();
    let tree_id = SHA1::from_str(&model.tree).unwrap();

    Commit::new(author, committer, tree_id, parent_commit_ids, &message)
}

/// Converts a mercury::internal::object::commit::Commit to callisto::git_commit::Model
///
/// This function takes a Git commit object and converts it to a database git commit model.
/// It serializes the parent commit IDs to JSON format for storage and sets the appropriate
/// metadata fields. The ID is set to 0 and will be generated by the database upon insertion.
pub fn commit_to_git_commit(commit: Commit, repo_id: i64) -> git_commit::Model {
    let parents_id = serde_json::to_string(
        &commit
            .parent_commit_ids
            .iter()
            .map(|id| id.to_string())
            .collect::<Vec<String>>(),
    )
    .unwrap();

    git_commit::Model {
        id: 0,
        repo_id,
        commit_id: commit.id.to_string(),
        tree: commit.tree_id.to_string(),
        parents_id: sea_orm::JsonValue::String(parents_id),
        author: Some(commit.author.to_string()),
        committer: Some(commit.committer.to_string()),
        content: Some(commit.message),
        created_at: chrono::Utc::now().naive_utc(),
    }
}

/// Converts a callisto::mega_commit::Model to mercury::internal::object::commit::Commit
///
/// This function takes a database mega commit model and converts it to a Git commit object.
/// It parses the parent commit IDs from JSON, extracts author and committer information,
/// and constructs a new Commit object with the appropriate data.
pub fn mega_commit_to_commit(model: mega_commit::Model) -> Commit {
    let parent_commit_ids: Vec<SHA1> =
        serde_json::from_str::<Vec<String>>(model.parents_id.to_string().as_str())
            .unwrap_or_default()
            .iter()
            .map(|id| SHA1::from_str(id).unwrap())
            .collect();

    let author = model
        .author
        .map(|a| Signature::from_data(a.into_bytes()).unwrap())
        .unwrap_or_else(|| {
            Signature::from_data(
                format!(
                    "author unknown <unknown@example.com> {} +0000",
                    chrono::Utc::now().timestamp()
                )
                .into_bytes(),
            )
            .unwrap()
        });

    let committer = model
        .committer
        .map(|c| Signature::from_data(c.into_bytes()).unwrap())
        .unwrap_or_else(|| {
            Signature::from_data(
                format!(
                    "committer unknown <unknown@example.com> {} +0000",
                    chrono::Utc::now().timestamp()
                )
                .into_bytes(),
            )
            .unwrap()
        });

    let message = model.content.unwrap_or_default();
    let tree_id = SHA1::from_str(&model.tree).unwrap();

    Commit::new(author, committer, tree_id, parent_commit_ids, &message)
}

/// Converts a mercury::internal::object::commit::Commit to callisto::mega_commit::Model
///
/// This function takes a Git commit object and converts it to a database mega commit model.
/// It serializes the parent commit IDs to JSON format for storage and sets the appropriate
/// metadata fields. The ID is set to 0 and will be generated by the database upon insertion.
pub fn commit_to_mega_commit(commit: Commit) -> mega_commit::Model {
    let parents_id = serde_json::to_string(
        &commit
            .parent_commit_ids
            .iter()
            .map(|id| id.to_string())
            .collect::<Vec<String>>(),
    )
    .unwrap();

    mega_commit::Model {
        id: 0,
        commit_id: commit.id.to_string(),
        tree: commit.tree_id.to_string(),
        parents_id: sea_orm::JsonValue::String(parents_id),
        author: Some(commit.author.to_string()),
        committer: Some(commit.committer.to_string()),
        content: Some(commit.message),
        created_at: chrono::Utc::now().naive_utc(),
    }
}

/// Converts a callisto::git_tag::Model to mercury::internal::object::tag::Tag
///
/// This function takes a database git tag model and converts it to a Git tag object.
/// It parses the object type, creates a tagger signature, and constructs a new Tag
/// object with the appropriate data.
pub fn git_tag_to_tag(model: git_tag::Model) -> Tag {
    let object_type = match model.object_type.as_str() {
        "commit" => ObjectType::Commit,
        "tree" => ObjectType::Tree,
        "blob" => ObjectType::Blob,
        "tag" => ObjectType::Tag,
        _ => ObjectType::Blob,
    };

    let tagger = Signature::from_data(format!("tagger {}", model.tagger).into_bytes())
        .unwrap_or_else(|_| {
            Signature::from_data(
                format!(
                    "tagger unknown <unknown@example.com> {} +0000",
                    chrono::Utc::now().timestamp()
                )
                .into_bytes(),
            )
            .unwrap()
        });

    let object_hash = SHA1::from_str(&model.object_id).unwrap();
    let tag_name = model.tag_name.clone();
    let message = model.message.clone();

    Tag::new(object_hash, object_type, tag_name, tagger, message)
}

/// Converts a mercury::internal::object::tag::Tag to callisto::git_tag::Model
///
/// This function takes a Git tag object and converts it to a database git tag model.
/// It sets the appropriate metadata fields and associates the tag with a repository.
/// The ID is set to 0 and will be generated by the database upon insertion.
pub fn tag_to_git_tag(tag: Tag, repo_id: i64) -> git_tag::Model {
    git_tag::Model {
        id: 0,
        repo_id,
        tag_id: tag.id.to_string(),
        object_id: tag.object_hash.to_string(),
        object_type: tag.object_type.to_string(),
        tag_name: tag.tag_name,
        tagger: tag.tagger.to_string(),
        message: tag.message,
        created_at: chrono::Utc::now().naive_utc(),
    }
}
